#version 450 core
layout(location=0) in vec3 vertexPosition_modelspace;

//Recupere le layer pour les normals maps
layout(location=1) in vec3 vertexNormal_modelspace;

//Recupere le layer définit dans le "glVertexAttribPointer" defini a 1 
layout(location=2) in vec2 vertexUV;

layout(location=4) in vec3 vertexTangent_modelspace;

layout(location=5) in vec3 vertexBitangent_modelspace;



//Definir la sortie
out vec2 UV;

out vec3 Normal_cameraspace;

out vec3 LightDirection_cameraspace;

out vec3 EyeDirection_cameraspace;

out vec3 LightDirection_tangentspace;
out vec3 EyeDirection_tangentspace;

out vec4 Position_worldspace;
out  vec4 LightPosition_worldspaceF;



//Valeur reste constante pour tout le mesh. Cette valeur est charge depuis le code 
//du moteur.
uniform mat4 MVP;

//Separation  des matrices M et V pour pouvoir traiter les lumieres sans prendre en compte la perspective
uniform mat4 M;

uniform mat4 V;

uniform mat3 matrixMV3x3;

//uniform vec4 LightPosition_worldspace;

//Recuperation de la position de la lumiere

uniform vec3 LightPosition_worldspace;

void main(){
	//gl_Position est le seul attribut fix de la carte graphique, puisque la position des vertex est la seul chose obligatoire.
	gl_Position = MVP * vec4(vertexPosition_modelspace,1);

	//---- Calcule des lumieres -------------

	// Position du vertex dans le monde
	// Position_worldspace = ( M * vec4(vertexPosition_modelspace,1)).xyzw;

	//Creation du vecteur venant du vertex a la camera, dans l'espace camera.
	// Dans lespace de la camera, la camera est à la position (0,0,0)
	vec3 vertexPosition_cameraspace = (V * M * vec4(vertexPosition_modelspace,1)).xyz;
    EyeDirection_cameraspace = vec3(0,0,0)- vertexPosition_cameraspace;


	//Calcule la direction de la liûmière depuis le vertex à la lumière.
	vec3 LightPosition_cameraspace = (V * vec4(LightPosition_worldspace,1)).xyz;
	LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;


	//Normal du vertex

	Normal_cameraspace = (V * M * vec4(vertexNormal_modelspace,0)).xyz;  // Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.


	//------ Normals Map Calcul ----------------------//


	vec3 vertexNormal_cameraSpace_3x3 = normalize(matrixMV3x3 * vertexNormal_modelspace);
	vec3 vertexTangent_cameraSpace = normalize(matrixMV3x3 * vertexTangent_modelspace);
	vec3 vertexBitangent_cameraSpace = normalize(matrixMV3x3 * vertexBitangent_modelspace);

	//L'utilisation de la transposition est plus rapide qu'une inversion de matrice. Du coup on devra corriger des
	//vecteurs dasn le fragment shader.
	mat3 TBN = transpose(mat3(vertexTangent_cameraSpace,vertexBitangent_cameraSpace,vertexNormal_cameraSpace_3x3));
	LightDirection_tangentspace = TBN * LightDirection_cameraspace;
    EyeDirection_tangentspace =  TBN * EyeDirection_cameraspace;

	//La couleur de chaque vertex vont etre interpolle
	//pour produir une couleur pour chaque fragment
	
	UV = vec2(vertexUV.x,-vertexUV.y);

	LightPosition_worldspaceF = vec4(LightPosition_worldspace,1);

}