#version 450 core
layout(location=0) in vec3 vertexPosition_modelspace;

//Recupere le layer pour les normals maps
layout(location=1) in vec3 vertexNormal_modelspace;

//Recupere le layer définit dans le "glVertexAttribPointer" defini a 1 
layout(location=2) in vec2 vertexUV;

//Definir la sortie
out vec2 UV;

out vec3 Normal_cameraspace;

out vec3 LightDirection_cameraspace;

out vec3 EyeDirection_cameraspace;

//Valeur reste constante pour tout le mesh. Cette valeur est charge depuis le code 
//du moteur.
uniform mat4 MVP;

//Separation  des matrices M et V pour pouvoir traiter les lumieres sans prendre en compte la perspective
uniform mat4 M;

uniform mat4 V;

//uniform vec4 LightPosition_worldspace;

//Recuperation de la position de la lumiere

uniform vec3 LightPosition_worldspace;

void main(){
	//gl_Position est le seul attribut fix de la carte graphique, puisque la position des vertex est la seul chose obligatoire.
	gl_Position = MVP * vec4(vertexPosition_modelspace,1);

	//---- Calcule des lumieres -------------

	// Position du vertex dans le monde
	// Position_worldspace = ( M * vec4(vertexPosition_modelspace,1)).xyz;

	//Creation du vecteur venant du vertex a la camera, dans l'espace camera.
	// Dans lespace de la camera, la camera est à la position (0,0,0)
	vec3 vertexPosition_cameraspace = (V * M * vec4(vertexPosition_modelspace,1)).xyz;
    EyeDirection_cameraspace = vec3(0,0,0)- vertexPosition_cameraspace;


	//Calcule la direction de la liûmière depuis le vertex à la lumière.
	vec3 LightPosition_cameraspace = (V * vec4(LightPosition_worldspace,1)).xyz;
	LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;


	//Normal du vertex

	Normal_cameraspace = (V * M * vec4(vertexNormal_modelspace,0)).xyz;  // Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.


	//La couleur de chaque vertex vont etre interpolle
	//pour produir une couleur pour chaque fragment
	
	UV = vec2(vertexUV.x,-vertexUV.y);

}